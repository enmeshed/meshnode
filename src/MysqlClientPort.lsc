import { NodeLocalPort } from '@enmeshed/mesh-reflection'
import { errors } from '@enmeshed/errors'
import { log } from './logging/logging'

mysql = require('mysql2/promise')

export class MysqlClientPort extends NodeLocalPort:
  poolsByName = {}

  constructor(node, service) ->
    super(node)
    this.service = service

  createPool(name, overrides) -/>
    if not this.dbConf:
      throw new errors.InternalError("MySQLClientPort: not started")

    if typeof(name) != 'string' or (not name):
      throw new errors.InvalidArgumentError('name', 'must be a nonempty string')

    if this.poolsByName[name]:
      throw new errors.AlreadyExistsError("pool", name)

    conf = Object.assign({}, this.dbConf, overrides)
    pool = mysql.createPool(conf)
    this.poolsByName[name] = pool
    pool

  destroyPool(name) -/>
    if typeof(name) != 'string' or (not name):
      throw new errors.InvalidArgumentError('name', 'must be a nonempty string')

    pool = this.poolsByName[name]
    if not pool:
      throw new errors.NotFoundError('pool', name)

    <- pool.end()
    this.poolsByName[name] = undefined

    return

  shutdown() -/>
    log.info(`stopping mysql client for ${this.service.name}`)
    this.dbConf = null
    lastPools = this.poolsByName
    this.poolsByName = {}
    <- [...for val pool in lastPools: [pool.end()]]
    return

  start() -/>
    // If we already have open pools, this service was already started
    if Object.keys(this.poolsByName).length > 0:
      throw new errors.InternalError(`mysql client for ${this.service.name} was already started`)

    { node, service } = this
    provider <- service.awaitProvider(30000)

    // Determine default mysql config
    this.dbConf = {
      host: provider.host
      port: provider.port
      database: provider.database
      user: provider.user
      password: node.getInjectedSecret(provider.passwordSecretId)
    }

  reconfigure(provider, service) ->
    // Reconfigure if mysql args change
    return
