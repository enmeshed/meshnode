import { NodeLocalPort } from '@enmeshed/mesh-reflection'
import { ServerEnhancer } from '@enmeshed/grpc'
import { CommonError, errors } from '@enmeshed/errors'
import * as opentracing from "opentracing"

import { createContext, getNode } from './globalContext'
import { ExtensionHeader } from './ExtensionHeader'

grpc = require('@grpc/grpc-js')
jaegerClient = require('jaeger-client')

debug = require('debug')('meshnode:grpc')

class TracingServerEnhancer extends ServerEnhancer:
  constructor(server, tracer, errorCodec) ->
    super(server)
    this.tracer = tracer
    this.errorCodec = errorCodec

  // Encode CommonErrors as metadata
  marshalError(err) ->
    if not (err instanceof CommonError): return err

    let buf = null
    try:
      // XXX: Should we be using production censorship here? Probably should
      // be a context dependent check.
      now buf = this.errorCodec.statusToBuffer(this.errorCodec.marshalError(err))
    catch encodeError:
      debug('Error while encoding another error for transport', encodeError)

    // Apply fields to the error that will be transferred to the Status
    // object by grpc.js
    err.code = err.getStatusCode()
    err.metadata = new grpc.Metadata()
    if buf: err.metadata.set('grpc-status-bin', buf)

    err

  requestWillBegin(requestContext): void ->
    super.requestWillBegin(requestContext)

    { tracer } = this
    globalContext = createContext()

    { metadata, methodName } = requestContext

    headerMap = (metadata?.getMap() or {})
    debug("TracingServerEnhancer.requestWillBegin:", methodName, "headerMap", headerMap)

    ///////////// extension header
    extensionHeader = ExtensionHeader.setFromHeaderData(headerMap)
    requestContext.extensionHeader = extensionHeader

    ///////////// OpenTracing context
    wireCtx = tracer.extract(opentracing.FORMAT_HTTP_HEADERS, headerMap)
    span = if wireCtx:
      debug("TracingServerEnhancer.requestWillBegin:", methodName, "creating child span for parent", wireCtx?._spanIdStr)
      tracer.startSpan(requestContext.methodName, {childOf: wireCtx})
    else:
      debug("TracingServerEnhancer.requestWillBegin:", methodName, "creating free span")
      tracer.startSpan(requestContext.methodName)
    globalContext.openTracingSpan = span
    requestContext.openTracingSpan = span

    span.setTag("span.kind", "server")
    span.log({event: "request_received"})

  requestDidEnd(requestContext): void ->
    super.requestDidEnd(requestContext)

    { error, methodName, result } = requestContext
    if error:
      debug("TracingServerEnhancer.requestDidEnd:", methodName, "error:", error)
    elif result:
      debug("TracingServerEnhancer.requestDidEnd:", methodName, "result:", result)

    span = requestContext.openTracingSpan
    if not span: return

    if error:
      // TODO: not-found errors are OK and do not need to be logged.
      span.setTag("error", true)
      span.setTag("sampling.priority", 1)
      span.log({
        event: "error"
        "error.message": error.stack or error.message
        error: error
      })
    else:
      span.log({event: "request_finished"})

    span.finish()

export class GrpcServicePort extends NodeLocalPort:
  running = false
  provider = null
  service = null
  grpcBindings = {}

  constructor(node, provider, service, isMesh) ->
    super(node)
    this.provider = provider
    this.service = service
    this.isMesh = isMesh

    // Create Jaeger tracer for this service
    this.tracer = jaegerClient.initTracer(
      {
        serviceName: service.name
      }
    )

  bind(protoName, bindings) ->
    this.grpcBindings[protoName] = bindings

  reconfigure(provider, service) ->
    // We only need to reconfigure if our local port number would have
    // changed, or if the required protocols changed.
    return

  start(): void -/>
    if this.server:
      throw new errors.InternalError(`GrpcServicePort.start(): service already running`)

    { protocols } = this.service
    for elem proto in protocols:
      if not this.grpcBindings[proto]:
        throw new errors.UnimplementedError(`GrpcMeshServicePort.start(): service ${this.service.name} does not implement required protocol ${proto}`)

    let port = this.service.port

    // For mesh services, automatically determine the port
    if this.isMesh:
      portIndex = this.provider.getServiceOrdinal(this.service)
      if portIndex == null:
        throw new errors.InternalError(`GrpcMeshServicePort.start(): port not found`)

      now port = this.node.ports.host_base + portIndex

    // Dynamically load protobufs definitions required for this service
    { protos } = this.node
    <- protos.findAll(...protocols)

    baseServer = new grpc.Server()
    enhServer = new TracingServerEnhancer(baseServer, this.tracer, this.node.errorCodec)
    this.server = enhServer

    for key svcName, val bindings in this.grpcBindings:
      svcDef = protos.lookup(svcName)
      if not svcDef:
        throw new errors.InternalError(`GrpcMeshServicePort.start(): service ${svcName} could not be resolved by dynamic loader.`)
      enhServer.addService(svcDef.methods, bindings)

    <- enhServer.bind(`0.0.0.0:${port}`, grpc.ServerCredentials.createInsecure())
    enhServer.start()
    debug('started gRPC server for', this.service.name, 'on port', port)

  shutdown(): void -/>
    debug('stopping gRPC server for', this.service.name)
    if this.server:
      <- this.server.shutdown()
      this.server = null
