import { NodeLocalPort } from '@enmeshed/mesh-reflection'
import { ClientEnhancer } from '@enmeshed/grpc'
import { errorClassForCode } from '@enmeshed/errors'
import * as opentracing from 'opentracing'

import { getContext } from './globalContext'

debug = require('debug')('meshnode:grpc')

decodeErrorFromGrpcMetadata(metadata, codec) ->
  if not metadata: return null
  buf = metadata.get('grpc-status-bin')
  if not buf: return null
  codec.unmarshalError(buf)

// Append OpenTracing and extension header data to grpc calls
class TracingClientEnhancer extends ClientEnhancer:
  constructor(client, errorCodec) ->
    super(client)
    this.errorCodec = errorCodec

  // Translate an error object from the remote to a CommonError.
  unmarshalError(err) ->
    try:
      // If the error came from the remote, it has {code, details, metadata}
      // Check metadata for a serialized error object first.
      if err.metadata:
        nextErr = decodeErrorFromGrpcMetadata(err.metadata, this.errorCodec)
        if nextErr: return nextErr

      // Try to make a CommonError using the grpc status code.
      if err.code:
        clazz = errorClassForCode(err.code)
        if clazz:
          nextErr = new clazz()
          nextErr.message = err.message or err.details
          return nextErr

      // Otherwise just return the regular error
      return err

    catch unmarshallingError:
      debug('error while unmarshalling remote error', unmarshallingError, '\n----\nremote error was originally', err)
      return err

  requestWillBegin(requestContext): void ->
    super.requestWillBegin(requestContext)

    { metadata } = requestContext
    globalContext = getContext()
    headersCarrier = {}

    // Inject opentracing data
    span = globalContext.openTracingSpan
    if span:
      tracer = span.tracer()
      tracer.inject(span, opentracing.FORMAT_HTTP_HEADERS, headersCarrier)

    // Inject extension header
    extensionHeader = globalContext.extensionHeader
    if extensionHeader and (metadata.get('x-mesh-extension').length == 0):
      headerData = extensionHeader.toHeaderData()
      Object.assign(headersCarrier, headerData)

    // Update request headers
    for key k, val v in headersCarrier:
      metadata.set(k, v)

    debug("client.requestWillBegin: new grpc metadata is", metadata)

export class GrpcClientPort extends NodeLocalPort:
  clientsForProto = {}

  constructor(node, service, isMesh) ->
    super(node)
    this.service = service
    this.isMesh = isMesh

  clientForProtocol(protoName) -/>
    { node, service, clientsForProto, isMesh } = this
    if clientsForProto[protoName]: return clientsForProto[protoName]

    if not (service.protocols?.includes(protoName)):
      throw new Error(`Service ${service.name} does not support protocol ${protoName}`)

    // Obtain protocol definition
    { protos } = node
    def <- protos.definition(protoName)

    // Obtain service target URL
    url = if this.node.TEST_URL_OVERRIDE:
      this.node.TEST_URL_OVERRIDE
    elif isMesh:
      `http://127.0.0.1:${node.ports.outgoing_proxy}/grpc/${service.name}`
    else:
      if not service.provider:
        throw new Error(`Direct grpc service ${service.name} does not have a provider.`)
      `${service.provider.dns}:${service.port}`

    baseClient = def.createClient(url)
    enhancedClient = new TracingClientEnhancer(baseClient, node.errorCodec)
    clientsForProto[protoName] = enhancedClient

    enhancedClient

  start() -/> return
  reconfigure(provider, service) ->
    // For mesh services:
    // We only need to reconfigure if the service has changed protocols.
    // If it has, dump all existing clients.
    //
    // For direct services:
    // We need to reconfigure if the host or port of the provider changes, or
    // if protocols change.
    return

  shutdown() -/>
    debug('stopping gRPC client for', this.service.name)
    this.clientsForProto = {}
    return
