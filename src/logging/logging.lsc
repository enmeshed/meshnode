globalThis = require('globalthis')()

levelNameToNumber = {
  MIN: 1
  trace: 10
  debug: 20
  info: 30
  warn: 40
  error: 50
  fatal: 60
  MAX: 100
}

MAX_LOG_LEVEL = levelNameToNumber.MAX

levelNumberToName = {...for key k, val v in levelNameToNumber: {[v]: k}}

export class Log:
  static levelNameToNumber(name) ->
    rst = levelNameToNumber[name]
    if rst~looseNotEq(null): rst else: 30

  static levelNumberToName(number) ->
    rst = levelNumberToName[number]
    if rst: rst else: "info"

  static addMiddleware(stackName, middleware, prepend): void ->
    ctx = getContext()
    stack = ctx[stackName]
    if stack:
      if prepend:
        ctx[stackName] = [middleware].concat(stack)
      else:
        ctx[stackName] = stack.concat([middleware])
    else:
      ctx[stackName] = [middleware]

  static addWriter(writer): void ->
    this.addMiddleware("logWriter", writer)
    ctx = getContext()
    ctx.minLogLevel = Math.min(ctx.minLogLevel or MAX_LOG_LEVEL, writer.level or MAX_LOG_LEVEL)

  static getMiddleware(stackName) ->
    getContext()?[stackName]

  static shouldLog(numericLevel): boolean ->
    targetLevel = getContext()?.minLogLevel or MAX_LOG_LEVEL
    if (targetLevel < MAX_LOG_LEVEL) and (numericLevel >= targetLevel): true else: false

  static doLog(data): void ->
    if not data.time: data.time = Date.now()
    if not data.level: data.level = "info"
    if not data.levelNumber: data.levelNumber = this.levelNameToNumber(this.level)
    filters = this.getMiddleware("logFilter")
    if filters:
      for elem filter in filters:
        filter.logEntry(data)
    writers = this.getMiddleware("logWriter")
    if writers:
      for elem writer in writers:
        writer.logEntry(data)

export class LogMiddleware:
  constructor(handler) ->
    if typeof(handler) == 'function':
      this.logEntry = handler.bind(this)

  // Called for each log entry the middleware sees.
  logEntry(data): void ->
    return

export class LogWriter extends LogMiddleware:
  level = 0

  setLevel(lv): LogWriter ->
    if typeof(lv) == 'number':
      this.level = lv
    else:
      this.level = Log.levelNameToNumber(lv)
    this

  // Filter events to be logged.
  filter(data): boolean ->
    if data.levelNumber < this.level:
      false
    else:
      true

  // Write a log event that's passed the filter.
  writeToLog(data): Promise<void> ->
    Promise.resolve(undefined)

  // Log information, ignoring failures.
  logEntry(data): void ->
    if this.filter(data):
      this.writeToLog(data)
        .catch((err) ->
          // eslint-disable-next-line no-console
          console.error("Error while writing to log", err)
        )


// Variadic log function
export vaLog(levelNumber, ...args): void ->
  levelName = Log.levelNumberToName(levelNumber)

  data = { level: levelName, levelNumber, time: Date.now(), message: '' }

  for elem arg in args:
    if typeof(arg) == 'string':
      if not data.message: data.message = arg else: data.message += ' ' + arg
    elif typeof(arg) == 'object':
      Object.assign(data, arg)
    else:
      data.message += arg

  Log.doLog(data)

logMethods = {
  trace(...args): void -> vaLog(10, ...args)
  debug(...args): void -> vaLog(20, ...args)
  info(...args): void -> vaLog(30, ...args)
  warn(...args): void -> vaLog(40, ...args)
  error(...args): void -> vaLog(50, ...args)
  fatal(...args): void -> vaLog(60, ...args)
}

// Log capability is global.
debugger
globalThis.log = logMethods

export { logMethods as log }
