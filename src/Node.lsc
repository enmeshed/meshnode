import { Node, NodeLocalPort } from '@enmeshed/mesh-reflection'
import { Protocols, ClientEnhancer, ServerEnhancer } from '@enmeshed/grpc'

import { HttpMeshServicePort } from './HttpServicePort'
import { createContext } from './globalContext'

grpc = require('@grpc/grpc-js')
debug = require('debug')('meshnode')

export class MeshNode extends Node:
  protos = new Protocols()
  ports = {
    incoming_proxy: 4000
    outgoing_proxy: 4001
    host_base: 40000
  }

  // Override for unit testing purposes
  TEST_URL_OVERRIDE = null

  constructor() ->
    super()

    // Create global context and add node to it.
    ctx = createContext()
    ctx.node = this

  _joined() -> return
  _createServicePort(provider, service) ->
    debug('_createServicePort', provider, service)
    match service.type:
      | 'grpc_direct': new GrpcServicePort(this, provider, service, false)
      | 'grpc_mesh': new GrpcServicePort(this, provider, service, true)
      | 'http_mesh': new HttpMeshServicePort(this, provider, service)
      | else: throw new Error('unrecognized service type ' + service.type)
  _createClientPort(service) ->
    match service.type:
      | 'grpc_mesh': new GrpcMeshClientPort(this, service)
      | else: throw new Error('unrecognized service type ' + service.type)

class GrpcServicePort extends NodeLocalPort:
  running = false
  provider = null
  service = null
  grpcBindings = {}

  constructor(node, provider, service, isMesh) ->
    super(node)
    this.provider = provider
    this.service = service
    this.isMesh = isMesh

  bind(protoName, bindings) ->
    this.grpcBindings[protoName] = bindings

  reconfigure(provider, service) ->
    this.provider = provider
    this.service = service

  start(): void -/>
    { protocols } = this.service
    for elem proto in protocols:
      if not this.grpcBindings[proto]:
        throw new Error(`GrpcMeshServicePort.start(): service ${this.service.name} does not implement required protocol ${proto}`)

    let port = this.service.port

    // For mesh services, automatically determine the port
    if this.isMesh:
      portIndex = this.provider.getServiceOrdinal(this.service)
      if portIndex == null:
        throw new Error(`GrpcMeshServicePort.start(): port not found`)

      now port = this.node.ports.host_base + portIndex

    // Load protobufs
    this.node.protos.load()

    baseServer = new grpc.Server()
    enhServer = new ServerEnhancer(baseServer)
    this.server = enhServer

    for key svcName, val bindings in this.grpcBindings:
      enhServer.addService(this.node.protos.service(svcName), bindings)

    <- enhServer.bind(`0.0.0.0:${port}`, grpc.ServerCredentials.createInsecure())
    enhServer.start()
    debug('started gRPC server for', this.service.name, 'on port', port)

  shutdown(): void -/>
    debug('stopping gRPC server for', this.service.name)
    server = this.server
    this.server = null
    server?.shutdown()

class GrpcMeshClientPort extends NodeLocalPort:
  clientsForProto = {}

  constructor(node, service) ->
    super(node)
    this.service = service

  clientForProtocol(protoName) ->
    { node, service, clientsForProto } = this
    if clientsForProto[protoName]: return clientsForProto[protoName]

    if not (service.protocols?.includes(protoName)):
      throw new Error(`Service ${service.name} does not support protocol ${protoName}`)

    { protos } = node
    protos.load()

    // Override service url for test harness
    url = if this.node.TEST_URL_OVERRIDE:
      this.node.TEST_URL_OVERRIDE
    else:
      `127.0.0.1:${node.ports.outgoing_proxy}/grpc/${service.name}`

    baseClient = protos.client(protoName, url)
    enhancedClient = new ClientEnhancer(baseClient)
    clientsForProto[protoName] = enhancedClient

    enhancedClient

  start() -> return
  reconfigure(provider, service) -> return
  shutdown() ->
    debug('stopping gRPC client for', this.service.name)
    return
