import { Node } from '@enmeshed/mesh-reflection'
import { DynamicProtocols } from '@enmeshed/grpc'
import { installGlobalProtocol } from '@enmeshed/protobuf'
import { errors, ProtobufMarshal } from '@enmeshed/errors'

import { HttpMeshServicePort } from './HttpServicePort'
import { GrpcServicePort } from './GrpcServicePort'
import { GrpcClientPort } from './GrpcClientPort'
import { KafkaClientPort } from './KafkaClientPort'
import { MysqlClientPort } from './MysqlClientPort'
import { createContext } from './globalContext'
import { ExtensionHeader } from './ExtensionHeader'

import os from 'os'
import path from 'path'

debug = require('debug')('meshnode')

// Install common protocols related to marshalling and unmarshalling
// error objects into the global Protobuf namespace.
ProtobufMarshal.installProtos(installGlobalProtocol)

export class MeshNode extends Node:
  protos = new DynamicProtocols()
  ports = {
    incoming_proxy: 4000
    outgoing_proxy: 4001
    host_base: 40000
  }

  // XXX: Override for unit testing purposes
  // XXX: remove this, no longer needed
  TEST_URL_OVERRIDE = null

  constructor() ->
    super()

    // Create global context and add node to it.
    ctx = createContext()
    ctx.node = this

    // Add default protobuf include path, which is the working directory provided
    // to the app at startup
    this.protos.setProtoPath(path.resolve(this.getConfigPath(), 'protocols'))

    this.errorCodec = new ProtobufMarshal(this.protos)

    this.computeNodeName()
    this.installNodeShutdownHooks()

  debug(...args): void ->
    debug(...args)

  computeNodeName(): void ->
    this.name = os.hostname()
    debug('Computed node name:', this.name)

  getInjectedSecret(secretId): string ->
    process.env[secretId]

  getConfig(configId): string ->
    process.env[configId]

  getConfigPath(): string ->
    process.argv[2] or process.cwd()

  createExtensionHeader() ->
    new ExtensionHeader()

  // Try to gracefully handle node js shutdowns.
  installNodeShutdownHooks(): void ->
    self = this
    for elem type in ['unhandledRejection', 'uncaughtException']:
      process.on(type, (err, origin) -/>
        try:
          debug('process.on', type, err, origin)
          <- self.stop()
          process.exit(1)
        catch err:
          debug('graceless shutdown', type, err)
          process.exit(128)
      )

    for elem type in ['SIGTERM', 'SIGINT', 'SIGUSR2']:
      process.once(type, -/>
        try:
          debug('process.on', type)
          <- self.stop()
          process.exit(0)
        catch err:
          debug('graceless shutdown', type, err)
          process.exit(128)
      )

  _joined() -> return
  _createServicePort(provider, service) ->
    debug('_createServicePort', provider, service)
    match service.type:
      | 'grpc_direct': new GrpcServicePort(this, provider, service, false)
      | 'grpc_mesh': new GrpcServicePort(this, provider, service, true)
      | 'http_mesh': new HttpMeshServicePort(this, provider, service)
      | else:
        throw new errors.InternalError('unrecognized service type ' + service.type)
  _createClientPort(service) ->
    match service.type:
      | 'grpc_direct': new GrpcClientPort(this, service, false)
      | 'grpc_mesh': new GrpcClientPort(this, service, true)
      | 'kafka': new KafkaClientPort(this, service)
      | 'mysql': new MysqlClientPort(this, service)
      | else:
        throw new errors.InternalError('unrecognized service type ' + service.type)
